h1. gamelet.lua Framework

Gamelets are pieces of a complete game that can update and draw themselves. The idea is that you can write gamelets, then put instances of them onto a stack, and whatever's on top of the stack is what runs and draws. By changing the stack, you can control your game's logic.


h2. Usage

To use gamelets:

# Write your gamelet code.
# Put some initial gamelet instances on the stack.
# Call the gamelet hooks.
# Change the stack to control game logic.

You should @require "gamelet"@ in your main game script, as well as in gamelet files themselves.


h3. Writing Gamelets

Each gamelet generally goes in a separate file in the @gamedata/gamelets@ directory (check it out for some pre-written samples). You can customise this by setting @gamelet.location@:

<pre><code>
-- Load gamelets from the base gamedata/ directory.
gamelet.location = "gamedata"
</code></pre>

Gamelet scripts usually look like this:

<pre><code>
require "gamelet"

module(..., package.seeall)

MT = { __index = getfenv() }

-- Create a new instance of this gamelet.
function new(g, o)
    local inst = o or {}
    -- Prepare members of inst for use.
    setmetatable(inst, MT)
    return inst
end

-- Event handler.
-- self - this gamelet instance
-- e - the event
-- pos - the index of this gamelet in the stack
function event(self, e, pos)
    -- ...
end

-- Periodic logic update method.
-- self - as above
-- delta - milliseconds since the last update
-- pos - as above
function update(self, delta, pos)
    -- ...
end

-- Drawing method.
-- self - as above
-- pos - as above
function draw(self, pos)
    -- ...
end
</code></pre>

The above code acts much like normal Lua packages. On top of this, it has a @new@ function to create _gamelet instances_.

Each gamelet instance has 3 methods: @event@, @update@ and @draw@. They should contain the event handling logic, regular updating logic and drawing code respectively. They can also return values, as you'll see later.


h3. Initializing the Gamelet Stack

Once you've written a gamelet or two, it's time to use them in your main game script. To initialise the stack, make gamelet instances by loading them and calling their @new@ functions, then push them on:

<pre><code>
require "game"
require "gamelet"

function game.init()
    table.insert(gamelet.stack, gamelet("my_gamelet"):new())
end
</code></pre>


h3. Calling the Gamelet Hooks

The gamelet stack has @event@, @update@ and @draw@ methods that call the matching hook of the top-most gamelet. They can be included in your main game script like so:

<pre><code>
function game.event(e)
    return gamelet.stack:event(e)
end

function game.update(delta)
    return gamelet.stack:update(delta)
end

function game.draw()
    game.clearScreen()
    return gamelet.stack:draw()
end
</code></pre>

The @event@, @update@ and @draw@ methods of each gamelet can return @gamelet.NEXT@ to go one down the stack and repeat the same call in that gamelet if it's there.

If @event@, @update@ or @draw@ return any other value, it will be returned by the same method of @gamelet.stack@. For example, if you're using "game.lua":doc/game.textile, returning @game.GAME_REDRAW@ prompts a redraw of the game screen, while returning @game.GAME_QUIT@ ends the game loop.


h3. Controlling the Stack

Since calling the methods of @gamelet.stack@ calls the same method of the top-most gamelet instance, you can change the stack while the game is running to control your game's logic.

@gamelet.stack@ is a normal array (read: Lua table with numeric keys), so you can use Lua's built-in table methods to deal with it. For example, to switch out one gamelet instance on top of the stack for another:

<pre><code>
table.remove(gamelet.stack)
table.insert(gamelet.stack, gamelet("my_gamelet"):new{
    x = 1,
    y = "two",
    z = "Hello everybody!"
})
</code></pre>


h2. Summary

# Write gamelet code in @gamedata/gamelets@.
## Write a @new@ function.
## Write @event@, @update@ and @draw@ methods, which can return values.
# In your main script, push gamelet instances onto @gamelet.stack@.
# Call the @event@, @update@ and @draw@ methods of @gamelet.stack@.
# Back in your gamelets, change @gamelet.stack@ to control your game.

That's all!
